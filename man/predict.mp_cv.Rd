% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.mp_cv}
\alias{predict.mp_cv}
\title{Prediction for a Fitted "mp_cv" Object}
\usage{
\method{predict}{mp_cv}(object, newx = NULL, weight = NULL,
  overall_rec = TRUE, ...)
}
\arguments{
\item{object}{A fitted "mp_cv" object returned by "mpersonalized_cv" function}

\item{newx}{Covariate matrix of new patients. If not supplied, by default the prediction
is for the original dataset in the "mp_cv" object. Prediction results will differ
based on whether \code{newx} is provided or not. Similar to \code{predict.mp}.}

\item{weight}{A weight vector for the overall recommendation, only needed when \code{overall_rec = TRUE}.
By default, equal weights are assigned to each study/outcome.}

\item{overall_rec}{A logical value. If \code{overall_rec = TRUE}, an overall recommendation will
be provided as an weighted average of the optimal treatment from each individual study/outcome. Only useful
when \code{newx} is provided.}

\item{...}{not used}
}
\value{
A list object with two elements. Similar to the returned value of \code{predict.mp}, but now it only predicts
for the optimal parameter penalty.
\item{opt_treatment}{If \code{newx} is provided, a recommendation matrix with each row denoting a subject and
each column denoting a study/outcome; otherwise, each element is a list of vectors with each vector representing the optimal treatment
for each study/outcome. If \code{overall_rec = TRUE},
the weighted overall recommended treatment will be further provided as well.
If the overall recommened treatment is equal to 0.5, it means the weighted sum is equal for 0 and 1.}
\item{benefit_score}{Benefit scores computed from \eqn{g_1, \dots, g_K}. Similar to structure of \code{opt_treatment}.}
}
\description{
This function predicts optimal treatment of new subjects for a cross-validated mpersonalized model.
}
\examples{
set.seed(123)
sim_dat = simulated_dataset(n = 200, problem = "meta-analysis")
Xlist = sim_dat$Xlist; Ylist = sim_dat$Ylist; Trtlist = sim_dat$Trtlist

# fit different rules with group lasso penalty
mp_cvmod_diff = mpersonalized_cv(problem = "meta-analysis",
                                 Xlist = Xlist, Ylist = Ylist, Trtlist = Trtlist,
                                 penalty = "GL", single_rule = FALSE)

newx = matrix(rnorm(100 * mp_cvmod_diff$number_covariates), nrow = 100)

# predict on newx
pred_new = predict(object = mp_cvmod_diff, newx = newx, overall_rec = TRUE)

# predict on old dataset
pred_old = predict(object = mp_cvmod_diff)
set.seed(NULL)
}
